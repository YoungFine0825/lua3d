---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yangfan
--- DateTime: 2021/11/16 16:04
---固定管线渲染器

local luaMath = math
local luaPrint = print
local luaTable = table

---@class Renderer
local Renderer = declareClass("Renderer")

function Renderer:ctor()
    self.pixelBufferWidth = 0

    self.pixelBufferHeight = 0

    self.pixelAspect = 1

    self.pixelBuffer = {}

    self.depthBuffer = {}

    ---@type VertexObject
    self.vertexObject = nil

    ---@type matrix4x4
    self.mvpMatrix = matrix4x4.identity()

    ---@type matrix4x4
    self.screenMatrix = matrix4x4.identity()
end

---@public
function Renderer:Init(pixelBufferWid,pixelBufferHei)
    self:SetPixelDimension(pixelBufferWid,pixelBufferHei)
    for w = 0,pixelBufferWid - 1 do
        self.pixelBuffer[w] = {}
        self.depthBuffer[w] = {}
        for h = 0,pixelBufferHei - 1 do
            self.pixelBuffer[w][h] = {0,0,0}
            self.depthBuffer[w][h] = 0
        end
    end
end

function Renderer:UnInit()

end

---@public
function Renderer:SetPixelDimension(width,height)
    self.pixelBufferWidth = width
    self.pixelBufferHeight = height
    self.pixelAspect = width / height
    self.screenMatrix = matrix4x4.new(
            width / 2,0,0,width/2,
            0,height / 2 * -1,0,height / 2,
            0,0,0,0,
            0,0,0,0
    )
end

---@public
---@param matrix matrix4x4
function Renderer:SetMVPMatrix(matrix)
    self.mvpMatrix = matrix
end

---@public
function Renderer:BindVertexObject(vertexObject)
    self.vertexObject = vertexObject
end

---@public
---@param color Color
function Renderer:ClearPixelBuffer(color)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            p[1] = color.r
            p[2] = color.g
            p[3] = color.b
        end
    end
end

---@public
function Renderer:WritePixel(x,y,r,g,b)
    if not self.pixelBuffer[x] then
        return
    end
    local pixel = self.pixelBuffer[x][y]
    if pixel then
        pixel[1] = r
        pixel[2] = g
        pixel[3] = b
    end
end

---@public
function Renderer:OutputPixelBuffer(viewWidth,viewHeight)
    local loveGraphics = love.graphics
    local pW = luaMath.ceil(viewWidth / self.pixelBufferWidth)
    local pH = luaMath.ceil(viewHeight / self.pixelBufferHeight)
    --
    loveGraphics.setPointSize(pW)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            loveGraphics.setColor(p[1],p[2],p[3],1)
            --
            loveGraphics.points(x * pW,y * pH)
        end
    end
end

---@public
function Renderer:Draw()
    if not self.vertexObject then
        return
    end
    local vec4 = vector4
    local mat4x4 = matrix4x4
    local verticeNum = self.vertexObject.verticesNumber
    local screenPos = {}
    for vertexIdx = 1,verticeNum do
        local point = self.vertexObject:GetVertexData(1,vertexIdx)
        local vertex = vec4.new(point[1],point[2],point[3],1)
        local clipPos = self.mvpMatrix * vertex
        local canonical = clipPos:toVector3()
        local screenX,screenY = mat4x4.mulXYZW(self.screenMatrix,canonical.x,canonical.y,0,1)
        screenPos[vertexIdx] = {luaMath.floor(screenX),luaMath.floor(screenY)}
    end
    --
    local indicesData = self.vertexObject.indicesData
    for triIdx = 1,self.vertexObject.trianglesNumber do
        local startIdx = (triIdx - 1) * 3
        local p1 = screenPos[ indicesData[startIdx + 1] ]
        local p2 = screenPos[ indicesData[startIdx + 2] ]
        local p3 = screenPos[ indicesData[startIdx + 3] ]
        self:DrawLine(p1[1],p1[2],p2[1],p2[2])
        self:DrawLine(p2[1],p2[2],p3[1],p3[2])
        self:DrawLine(p3[1],p3[2],p1[1],p1[2])
    end
end

---@public
function Renderer:DrawLine(x0,y0,x1,y1)
    local swap = function(a,b)
        local t = a
        a = b
        b = t
        return a,b
    end
    local steep = luaMath.abs(y1 - y0) > luaMath.abs(x1 - x0)
    if steep then
        x0,y0 = swap(x0,y0)
        x1,y1 = swap(x1,y1)
    end
    if x0 > x1 then
        x0,x1 = swap(x0,x1)
        y0,y1 = swap(y0,y1)
    end
    local deltax = x1 - x0
    local deltay = luaMath.abs(y1 - y0)
    local error = 0
    local deltaerr = deltay / deltax
    local ystep = 0
    local y = y0
    if y0 < y1 then ystep = 1 else ystep = -1 end
    for x = x0,x1 do
        if steep then
            self:WritePixel(y,x,1,0,0)
        else
            self:WritePixel(x,y,1,0,0)
        end
        error = error + deltaerr
        if error >= 0.5 then
            y = y + ystep
            error = error - 1
        end
    end
end


return Renderer