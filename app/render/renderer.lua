---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yangfan
--- DateTime: 2021/11/16 16:04
---固定管线渲染器

local luaMath = math
local luaPrint = print
local luaTable = table

local vec3 = vector3
local vec4 = vector4
local mat4x4 = matrix4x4

---@class Renderer
local Renderer = declareClass("Renderer")

function Renderer:ctor()
    self.pixelBufferWidth = 0

    self.pixelBufferHeight = 0

    self.pixelAspect = 1

    self.pixelBuffer = {}

    self.depthBuffer = {}

    ---@type VertexObject
    self.vertexObject = nil

    self.modelViewMatrix = mat4x4.identity()

    self.projectionMatrix = mat4x4.identity()

    ---@type matrix4x4
    self.screenMatrix = mat4x4.identity()
end

---@public
function Renderer:Init(pixelBufferWid,pixelBufferHei)
    self:SetPixelDimension(pixelBufferWid,pixelBufferHei)
    for w = 0,pixelBufferWid - 1 do
        self.pixelBuffer[w] = {}
        self.depthBuffer[w] = {}
        for h = 0,pixelBufferHei - 1 do
            self.pixelBuffer[w][h] = {0,0,0}
            self.depthBuffer[w][h] = 0
        end
    end
end

function Renderer:UnInit()

end

---@public
function Renderer:SetPixelDimension(width,height)
    self.pixelBufferWidth = width
    self.pixelBufferHeight = height
    self.pixelAspect = width / height
    self.screenMatrix = matrix4x4.new(
            width / 2,0,0,width/2,
            0,height / 2 * -1,0,height / 2,
            0,0,0,0,
            0,0,0,0
    )
end
---@public
function Renderer:SetModelViewMatrix(modelViewMatrix)
    self.modelViewMatrix = modelViewMatrix
end

---@public
function Renderer:SetProjectionMatrix(projectionMatrix)
    self.projectionMatrix = projectionMatrix
end

---@public
function Renderer:BindVertexObject(vertexObject)
    self.vertexObject = vertexObject
end

---@public
---@param color Color
function Renderer:ClearPixelBuffer(color)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            p[1] = color.r
            p[2] = color.g
            p[3] = color.b
        end
    end
end

---@public
function Renderer:WritePixel(x,y,r,g,b)
    if not self.pixelBuffer[x] then
        return
    end
    local pixel = self.pixelBuffer[x][y]
    if pixel then
        pixel[1] = r
        pixel[2] = g
        pixel[3] = b
    end
end

---@public
function Renderer:OutputPixelBuffer(viewWidth,viewHeight)
    local loveGraphics = love.graphics
    local pW = luaMath.ceil(viewWidth / self.pixelBufferWidth)
    local pH = luaMath.ceil(viewHeight / self.pixelBufferHeight)
    --
    loveGraphics.setPointSize(pW)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            loveGraphics.setColor(p[1],p[2],p[3],1)
            --
            loveGraphics.points(x * pW + pW / 2,y * pH + pH / 2)
        end
    end
end

---@public
function Renderer:Draw()
    if not self.vertexObject then
        return
    end
    local verticeNum = self.vertexObject.verticesNumber
    local indicesData = self.vertexObject.indicesData
    local viewSpaceVertices = {}
    local clipSpaceVertices = {}
    local screenSpacePos = {}
    local visableVertices = {}
    local visableTriangles = {}
    --将所有顶点转换到观察空间
    for vertexIdx = 1,verticeNum do
        local point = self.vertexObject:GetVertexData(1,vertexIdx)
        local vertex = vec4.new(point[1],point[2],point[3],1)
        viewSpaceVertices[vertexIdx] = self.modelViewMatrix * vertex
    end
    --剔除背面的三角形
    for triIdx = 0,self.vertexObject.trianglesNumber - 1 do
        local startIdx = triIdx * 3
        local vertexIdx1 = indicesData[startIdx + 1]
        local vertexIdx2 = indicesData[startIdx + 2]
        local vertexIdx3 = indicesData[startIdx + 3]
        local p1 = viewSpaceVertices[ vertexIdx1 ]
        local p2 = viewSpaceVertices[ vertexIdx2 ]
        local p3 = viewSpaceVertices[ vertexIdx3 ]
        local p12 = p2 - p1
        local p13 = p3 - p1
        local vertical = vec3.cross(p12,p13)
        local toOri = vec3.new(0 - p1.x,0 - p1.y,0 - p1.z)
        local dot = vec3.dot(vertical,toOri)
        if dot < 0 then
            visableTriangles[#visableTriangles + 1] = triIdx
            visableVertices[vertexIdx1] = 1
            visableVertices[vertexIdx2] = 1
            visableVertices[vertexIdx3] = 1
        end
    end
    --将顶点转换到裁剪空间和屏幕空间
    for vertexIdx in pairs(visableVertices) do
        local clipPos = self.projectionMatrix * viewSpaceVertices[vertexIdx]
        clipSpaceVertices[vertexIdx] = clipPos
        local canonical = clipPos:toVector3()
        local screenX,screenY = mat4x4.mulXYZW(self.screenMatrix,canonical.x,canonical.y,0,1)
        screenSpacePos[vertexIdx] = {x = luaMath.floor(screenX),y = luaMath.floor(screenY)}
    end
    --光栅化三角形
    for i = 1,#visableTriangles do
        local startIdx = visableTriangles[i] * 3
        local p1 = screenSpacePos[ indicesData[startIdx + 1] ]
        local p2 = screenSpacePos[ indicesData[startIdx + 2] ]
        local p3 = screenSpacePos[ indicesData[startIdx + 3] ]
        self:TriangleRasterization(p1,p2,p3)
    end
end

---@private
function Renderer:TriangleRasterization(p1,p2,p3)
    local minX,maxX,minY,maxY = self:CalcuTriangleBound(p1,p2,p3)
    local f23 = function(x,y) return self:CalcuBarycentricCoord(p2,p3,x,y) end
    local f31 = function(x,y) return self:CalcuBarycentricCoord(p3,p1,x,y) end
    local f12 = function(x,y) return self:CalcuBarycentricCoord(p1,p2,x,y) end
    local alpha = f23(p1.x,p1.y)
    local beta  = f31(p2.x,p2.y)
    local gamma = f12(p3.x,p3.y)
    for y = minY,maxY do
        for x = minX,maxX do
            local a = f23(x,y) / alpha
            local b = f31(x,y) / beta
            local c = f12(x,y) / gamma
            if a >= 0 and b >= 0 and c >= 0 then
                self:WritePixel(x,y,0.5,0.5,1)
            end
        end
    end
end

---@private
function Renderer:CalcuTriangleBound(...)
    local minX = 0
    local maxX = 0
    local minY = 0
    local maxY = 0
    for idx,point in pairs({...}) do
        if point.x < minX then
            minX = point.x
        end
        if point.x > maxX then
            maxX = point.x
        end
        if point.y < minY then
            minY = point.y
        end
        if point.y > maxY then
            maxY = point.y
        end
    end
    return luaMath.floor(minX),luaMath.ceil(maxX),luaMath.floor(minY),luaMath.ceil(maxY)
end

---@private
function Renderer:CalcuBarycentricCoord(triP1,triP2,pixelX,pixelY)
    local ret = (triP1.y - triP2.y) * pixelX + (triP2.x - triP1.x) * pixelY + triP1.x * triP2.y - triP1.y * triP2.x
    return ret
end


---@public
function Renderer:DrawLine(x0,y0,x1,y1)
    local swap = function(a,b)
        local t = a
        a = b
        b = t
        return a,b
    end
    local steep = luaMath.abs(y1 - y0) > luaMath.abs(x1 - x0)
    if steep then
        x0,y0 = swap(x0,y0)
        x1,y1 = swap(x1,y1)
    end
    if x0 > x1 then
        x0,x1 = swap(x0,x1)
        y0,y1 = swap(y0,y1)
    end
    local deltax = x1 - x0
    local deltay = luaMath.abs(y1 - y0)
    local error = 0
    local slope = deltay / deltax
    local ystep = 0
    local y = y0
    if y0 < y1 then ystep = 1 else ystep = -1 end
    for x = x0,x1 do
        if steep then
            self:WritePixel(y,x,1,0,0)
        else
            self:WritePixel(x,y,1,0,0)
        end
        error = error + slope
        if error >= 0.5 then
            y = y + ystep
            error = error - 1
        end
    end
end

return Renderer