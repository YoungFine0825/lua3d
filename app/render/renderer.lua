---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yangfan
--- DateTime: 2021/11/16 16:04
---固定管线渲染器

local luaMath = math
local luaPrint = print
local luaTable = table

local vec2 = vector2
local vec3 = vector3
local vec4 = vector4
local mat4x4 = matrix4x4

local loveGraphics = love.graphics

---@class Renderer
local Renderer = declareClass("Renderer")

function Renderer:ctor()
    self.pixelBufferWidth = 0

    self.pixelBufferHeight = 0

    self.pixelAspect = 1

    self.pixelBuffer = {}

    self.depthBuffer = {}

    ---@type VertexObject
    self.vertexObject = nil

    self.viewMatrix = mat4x4.identity()

    self.projectionMatrix = mat4x4.identity()

    ---@type matrix4x4
    self.screenMatrix = mat4x4.identity()

    ---@type Shader
    self.shader = nil

    ---@type boolean
    self.canDrawing = false

    ---@type boolean
    self.enabledAlphaBlend = true

    ---@type boolean
    self.enabledDepthWrite = true
end

---@public
function Renderer:Init(pixelBufferWid,pixelBufferHei)
    self:SetPixelDimension(pixelBufferWid,pixelBufferHei)
    for w = 0,pixelBufferWid - 1 do
        self.pixelBuffer[w] = {}
        self.depthBuffer[w] = {}
        for h = 0,pixelBufferHei - 1 do
            self.pixelBuffer[w][h] = {0,0,0}
            self.depthBuffer[w][h] = 0
        end
    end
end

function Renderer:UnInit()

end

---@public
function Renderer:SetPixelDimension(width,height)
    self.pixelBufferWidth = width
    self.pixelBufferHeight = height
    self.pixelAspect = width / height
    self.screenMatrix = mat4x4.new(
            width / 2,0,0,width/2,
            0,height / 2 * -1,0,height / 2,
            0,0,0,0,
            0,0,0,0
    )
end
---@public
function Renderer:SetViewMatrix(viewMatrix)
    self.viewMatrix = viewMatrix
end

---@public
function Renderer:SetProjectionMatrix(projectionMatrix)
    self.projectionMatrix = projectionMatrix
end

---@public
function Renderer:BindVertexObject(vertexObject)
    self.vertexObject = vertexObject
end

---@public
---@param shader Shader
function Renderer:BindShader(shader)
    self.shader = shader
end

---@public
---@param color Color
function Renderer:ClearPixelBuffer(color)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            p[1] = color.r
            p[2] = color.g
            p[3] = color.b
            self.depthBuffer[x][y] = 0
        end
    end
end

---@private
function Renderer:WritePixel(x,y,r,g,b)
    if not self.pixelBuffer[x] then
        return
    end
    local pixel = self.pixelBuffer[x][y]
    if pixel then
        pixel[1] = r
        pixel[2] = g
        pixel[3] = b
    end
end

---@public
function Renderer:OutputPixelBuffer(viewWidth,viewHeight)

    local pW = viewWidth / self.pixelBufferWidth
    local pH = viewHeight / self.pixelBufferHeight
    --
    loveGraphics.setPointSize(pW + 0.5)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            loveGraphics.setColor(p[1],p[2],p[3],1)
            --
            loveGraphics.points(x * pW + pW / 2 ,y * pH + pH / 2  )
        end
    end
end

---@private
function Renderer:WriteDethBuffer(x,y,depth)
    self.depthBuffer[x][y] = depth
end

---@public 是否开启alpha融合
---@param enable boolean
function Renderer:EnableAlphaBlend(enable)
    self.enabledAlphaBlend = enable
end

---@public 是否开启深度写入
---@param enable boolean
function Renderer:EnableDepthWrite(enable)
    self.enabledDepthWrite = enable
end

---@public
function Renderer:Draw()
    self.canDrawing = self.vertexObject ~= nil and self.shader ~= nil
    if not  self.canDrawing then
        return
    end
    --
    if self.shader then
        --渲染前，传入一些shader需要的数据
        self.shader:SetMVPMatrix(self.projectionMatrix * self.viewMatrix)
        self.shader:SetVertexObject(self.vertexObject)
        --让Shader根据需求设置渲染状态
        self.shader:SetRenderState(self)
    end
    --
    local verticeNum = self.vertexObject.verticesNumber
    local indicesData = self.vertexObject.indicesData
    local viewSpaceVertices = {}
    local visableVertices = {}
    local visableTriangles = {}
    local vertexShaderOutputList = {}
    --
    --将所有顶点转换到观察空间
    for vertexIdx = 1,verticeNum do
        local point = self.vertexObject:GetVertexData(1,vertexIdx)
        local vertex = vec4.new(point[1],point[2],point[3],1)
        viewSpaceVertices[vertexIdx] = self.viewMatrix * vertex
    end
    --在观察空间中，剔除背面的三角形
    for triIdx = 0,self.vertexObject.trianglesNumber - 1 do
        local startIdx = triIdx * 3
        local vertexIdx1 = indicesData[startIdx + 1]
        local vertexIdx2 = indicesData[startIdx + 2]
        local vertexIdx3 = indicesData[startIdx + 3]
        local p1 = viewSpaceVertices[ vertexIdx1 ]
        local p2 = viewSpaceVertices[ vertexIdx2 ]
        local p3 = viewSpaceVertices[ vertexIdx3 ]
        local p12 = p2 - p1
        local p13 = p3 - p1
        --通过叉乘取三角形的法线。（我们使用的是右手坐标系)
        --p12 X p13
        local crossX = p12.y * p13.z - p12.z * p13.y
        local crossY = p12.z * p13.x - p12.x * p13.z
        local crossZ = p12.x * p13.y - p12.y * p13.x
        --通过点乘取三角形法线与三角形第一个点到原点的方向向量的夹角
        local dot = crossX * (0 - p1.x) + crossY * (0 - p1.y) + crossZ * (0 - p1.z)
        if dot > 0 then--夹角小于于90度，表示该三角形面向视点，需要渲染出来
            visableTriangles[#visableTriangles + 1] = triIdx
            visableVertices[vertexIdx1] = 1
            visableVertices[vertexIdx2] = 1
            visableVertices[vertexIdx3] = 1
        end
    end
    --执行顶点着色器，着色器应当返回顶点的裁剪空间坐标
    for vertexIdx in pairs(visableVertices) do
        self.shader:SetCurVertexIndex(vertexIdx)
        ---@type VertexShaderOutput
        local vertexShaderOutput = self.shader:VertexShader()
        if vertexShaderOutput.clipPos then
            vertexShaderOutputList[vertexIdx] = vertexShaderOutput
        end
    end
    --剔除位于剪裁空间外的三角形
    for i = #visableTriangles,1,-1 do
        local startIdx = visableTriangles[i] * 3
        local p1 = vertexShaderOutputList[ indicesData[startIdx + 1] ]
        local p2 = vertexShaderOutputList[ indicesData[startIdx + 2] ]
        local p3 = vertexShaderOutputList[ indicesData[startIdx + 3] ]
        if self:IsClipTri(p1.clipPos,p2.clipPos,p3.clipPos) then
            luaTable.remove(visableTriangles,i)
        end
    end
    --光栅化三角形
    local fragmentsCache = {}
    for i = 1,#visableTriangles do
        local startIdx = visableTriangles[i] * 3
        local vertexIdx1 = indicesData[startIdx + 1]
        local vertexIdx2 = indicesData[startIdx + 2]
        local vertexIdx3 = indicesData[startIdx + 3]
        local vertexShaderOutput1 = vertexShaderOutputList[ vertexIdx1 ]
        local vertexShaderOutput2 = vertexShaderOutputList[ vertexIdx2 ]
        local vertexShaderOutput3 = vertexShaderOutputList[ vertexIdx3 ]
        if vertexShaderOutput1 and vertexShaderOutput2 and vertexShaderOutput3 then
            local frag1 = fragmentsCache[vertexIdx1]
            if not frag1 then
                frag1 = self:GenFragmentInput(vertexShaderOutput1)
                fragmentsCache[vertexIdx1] = frag1
            end
            local frag2 = fragmentsCache[vertexIdx2]
            if not frag2 then
                frag2 = self:GenFragmentInput(vertexShaderOutput2)
                fragmentsCache[vertexIdx2] = frag2
            end
            local frag3 = fragmentsCache[vertexIdx3]
            if not frag3 then
                frag3 = self:GenFragmentInput(vertexShaderOutput3)
                fragmentsCache[vertexIdx3] = frag3
            end
            local p1 = frag1.screenPos
            local p2 = frag2.screenPos
            local p3 = frag3.screenPos
            local f23 = function(x,y) return self:CalcuBarycentricCoord(p2,p3,x,y) end
            local f31 = function(x,y) return self:CalcuBarycentricCoord(p3,p1,x,y) end
            local f12 = function(x,y) return self:CalcuBarycentricCoord(p1,p2,x,y) end
            local alpha = f23(p1.x,p1.y)
            local beta  = f31(p2.x,p2.y)
            local gamma = f12(p3.x,p3.y)
            local minX,maxX,minY,maxY = self:CalcuTriangleBound(p1,p2,p3)
            for y = minY,maxY do
                for x = minX,maxX do
                    --求像素在三角形中的重心坐标
                    local a = f23(x,y) / alpha
                    local b = f31(x,y) / beta
                    local c = f12(x,y) / gamma
                    if a >= 0 and b >= 0 and c >= 0 then
                        --使用重心坐标对齐次空间坐标进行插值，z分量作为片元的深度值
                        local fragmentDepth = frag1.rhw * a + frag2.rhw * b + frag3.rhw * c
                        local depthBuffer = self.depthBuffer[x][y]
                        --先进行深度测试（深度值越大表示越接近视点）
                        if depthBuffer == 0 or fragmentDepth > depthBuffer then
                            --写入深度值
                            if self.enabledDepthWrite then
                                self.depthBuffer[x][y] = fragmentDepth
                            end
                            --使用重心坐标进行片元差值
                            local fragment = self:FragmentInterpolation(a,b,c,frag1,frag2,frag3)
                            --执行片元着色器
                            local dstColorR,dstColorG,dstColorB,dstColorA = self.shader:FragmentShader(fragment)
                            --执行Alpha融合
                            local alphaFactor = self.enabledAlphaBlend and dstColorA or 1
                            local srcColor = self.pixelBuffer[x][y]
                            local finalR = srcColor[1] * (1 - alphaFactor) + dstColorR * alphaFactor
                            local finalG = srcColor[2] * (1 - alphaFactor) + dstColorG * alphaFactor
                            local finalB = srcColor[3] * (1 - alphaFactor) + dstColorB * alphaFactor
                            --把最终颜色写入像素缓存
                            self:WritePixel(x,y,finalR,finalG,finalB)
                        end
                        --
                    end
                end
            end
        end
    end
end

---@private 三角裁剪  根据据三 角形三个顶点是否都在裁剪空 间之外，决定三角形是否应该被裁减掉
---@param p1 vector4
---@param p2 vector4
---@param p3 vector4
function Renderer:IsClipTri(p1,p2,p3)
    local w = p1.w
    local negW = w * -1
    local isP1Visable = (p1.x <= w and p1.x >= negW) and (p1.y <= w and p1.y >= negW)and (p1.z <= w and p1.z >= negW)
    w = p2.w
    negW = w * -1
    local isP2Visable = (p2.x <= w and p2.x >= negW) and (p2.y <= w and p2.y >= negW)and (p2.z <= w and p2.z >= negW)
    w = p3.w
    negW = w * -1
    local isP3Visable = (p3.x <= w and p3.x >= negW) and (p3.y <= w and p3.y >= negW)and (p3.z <= w and p3.z >= negW)
    return not isP1Visable and not isP2Visable and not isP3Visable
end


---@private
---@param input VertexShaderOutput
---@return FragmentShaderInput
function Renderer:GenFragmentInput(input)
    ---@type FragmentShaderInput
    local fragmentShaderInput = {}
    local ve3One = vec3.one()
    --
    for k,v in pairs(input) do
        --通过做一次乘法达到克隆的目的
        fragmentShaderInput[k] = v * ve3One
    end
    local clipPos = input.clipPos
    --计算 w 的倒数：Reciprocal of the Homogeneous W
    local w = input.clipPos.w
    local rhw = 1 / (w ~= 0 and w or 1)
    --裁剪空间坐标转为齐次空间坐标
    local canonicalPos = vec3.new(clipPos.x * rhw,clipPos.y * rhw,clipPos.z * rhw)
    --变换到屏幕坐标
    local screenX,screenY = mat4x4.mulXYZW(self.screenMatrix,canonicalPos.x,canonicalPos.y,0,1)
    fragmentShaderInput.screenPos = vec2.new(luaMath.floor(screenX) + 0.5,luaMath.floor(screenY) + 0.5)
    fragmentShaderInput.rhw = rhw
    return fragmentShaderInput
end

---@private 计算2d空间三角形轴对称包围盒
function Renderer:CalcuTriangleBound(p1,p2,p3)
    local minX = 0
    local maxX = 0
    local minY = 0
    local maxY = 0
    local Math = luaMath
    --
    minX = Math.min(minX,p1.x)
    maxX = Math.max(maxX,p1.x)
    minY = Math.min(minY,p1.y)
    maxY = Math.max(maxY,p1.y)
    --
    minX = Math.min(minX,p2.x)
    maxX = Math.max(maxX,p2.x)
    minY = Math.min(minY,p2.y)
    maxY = Math.max(maxY,p2.y)
    --
    minX = Math.min(minX,p3.x)
    maxX = Math.max(maxX,p3.x)
    minY = Math.min(minY,p3.y)
    maxY = Math.max(maxY,p3.y)
    return luaMath.max(luaMath.floor(minX),0),
    luaMath.min( luaMath.ceil(maxX), self.pixelBufferWidth - 1),
    luaMath.max( luaMath.floor(minY), 0),
    luaMath.min( luaMath.ceil(maxY),self.pixelBufferHeight - 1)
end

---@private
function Renderer:CalcuBarycentricCoord(triP1,triP2,pixelX,pixelY)
    local ret = (triP1.y - triP2.y) * pixelX + (triP2.x - triP1.x) * pixelY + triP1.x * triP2.y - triP1.y * triP2.x
    return ret
end

---@private
---@return FragmentShaderInput
function Renderer:FragmentInterpolation(x,y,z,frag1,frag2,frag3)
    local ret = {}
    for k in pairs(frag1) do
        --if k == 'normal' then
        --    local rhw = frag1.rhw * x + frag2.rhw * y + frag3.rhw * z
        --    local w = 1 / (rhw ~= 0 and rhw or 1)
        --    local c1 = frag1.rhw * x * w
        --    local c2 = frag2.rhw * y * w
        --    local c3 = frag3.rhw * z * w
        --    ret[k] = frag1[k] * c1 + frag2[k] * c2 + frag3[k] * c3
        --else
        --    ret[k] = frag1[k] * x + frag2[k] * y + frag3[k] * z
        --end
        ret[k] = frag1[k] * x + frag2[k] * y + frag3[k] * z
    end
    return ret
end


---@public
function Renderer:DrawLine(x0,y0,x1,y1)
    local swap = function(a,b)
        local t = a
        a = b
        b = t
        return a,b
    end
    local steep = luaMath.abs(y1 - y0) > luaMath.abs(x1 - x0)
    if steep then
        x0,y0 = swap(x0,y0)
        x1,y1 = swap(x1,y1)
    end
    if x0 > x1 then
        x0,x1 = swap(x0,x1)
        y0,y1 = swap(y0,y1)
    end
    local deltax = x1 - x0
    local deltay = luaMath.abs(y1 - y0)
    local error = 0
    local slope = deltay / deltax
    local ystep = 0
    local y = y0
    if y0 < y1 then ystep = 1 else ystep = -1 end
    for x = x0,x1 do
        if steep then
            self:WritePixel(y,x,1,0,0)
        else
            self:WritePixel(x,y,1,0,0)
        end
        error = error + slope
        if error >= 0.5 then
            y = y + ystep
            error = error - 1
        end
    end
end

return Renderer