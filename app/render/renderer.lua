---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by yangfan
--- DateTime: 2021/11/16 16:04
---固定管线渲染器

local luaMath = math
local luaPrint = print
local luaTable = table

local vec2 = vector2
local vec3 = vector3
local vec4 = vector4
local mat4x4 = matrix4x4

---@class Renderer
local Renderer = declareClass("Renderer")

function Renderer:ctor()
    self.pixelBufferWidth = 0

    self.pixelBufferHeight = 0

    self.pixelAspect = 1

    self.pixelBuffer = {}

    self.depthBuffer = {}

    ---@type VertexObject
    self.vertexObject = nil

    self.viewMatrix = mat4x4.identity()

    self.projectionMatrix = mat4x4.identity()

    ---@type matrix4x4
    self.screenMatrix = mat4x4.identity()

    ---@type Shader
    self.shader = nil

    ---@type boolean
    self.canDrawing = false

    ---@type boolean
    self.enabledAlphaBlend = true

    ---@type boolean
    self.enabledDepthWrite = true
end

---@public
function Renderer:Init(pixelBufferWid,pixelBufferHei)
    self:SetPixelDimension(pixelBufferWid,pixelBufferHei)
    for w = 0,pixelBufferWid - 1 do
        self.pixelBuffer[w] = {}
        self.depthBuffer[w] = {}
        for h = 0,pixelBufferHei - 1 do
            self.pixelBuffer[w][h] = {0,0,0}
            self.depthBuffer[w][h] = 0
        end
    end
end

function Renderer:UnInit()

end

---@public
function Renderer:SetPixelDimension(width,height)
    self.pixelBufferWidth = width
    self.pixelBufferHeight = height
    self.pixelAspect = width / height
    self.screenMatrix = mat4x4.new(
            width / 2,0,0,width/2,
            0,height / 2 * -1,0,height / 2,
            0,0,0,0,
            0,0,0,0
    )
end
---@public
function Renderer:SetViewMatrix(viewMatrix)
    self.viewMatrix = viewMatrix
end

---@public
function Renderer:SetProjectionMatrix(projectionMatrix)
    self.projectionMatrix = projectionMatrix
end

---@public
function Renderer:BindVertexObject(vertexObject)
    self.vertexObject = vertexObject
end

---@public
---@param shader Shader
function Renderer:BindShader(shader)
    self.shader = shader
end

---@public
---@param color Color
function Renderer:ClearPixelBuffer(color)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            p[1] = color.r
            p[2] = color.g
            p[3] = color.b
            self.depthBuffer[x][y] = 0
        end
    end
end

---@private
function Renderer:WritePixel(x,y,r,g,b)
    if not self.pixelBuffer[x] then
        return
    end
    local pixel = self.pixelBuffer[x][y]
    if pixel then
        pixel[1] = r
        pixel[2] = g
        pixel[3] = b
    end
end

---@public
function Renderer:OutputPixelBuffer(viewWidth,viewHeight)
    local loveGraphics = love.graphics
    local pW = luaMath.ceil(viewWidth / self.pixelBufferWidth)
    local pH = luaMath.ceil(viewHeight / self.pixelBufferHeight)
    --
    loveGraphics.setPointSize(pW)
    for x = 0,self.pixelBufferWidth - 1 do
        for y = 0,self.pixelBufferHeight - 1 do
            local p = self.pixelBuffer[x][y]
            loveGraphics.setColor(p[1],p[2],p[3],1)
            --
            loveGraphics.points(x * pW + pW / 2 ,y * pH + pH / 2)
        end
    end
end

---@private
function Renderer:WriteDethBuffer(x,y,depth)
    self.depthBuffer[x][y] = depth
end

---@public 是否开启alpha融合
---@param enable boolean
function Renderer:EnableAlphaBlend(enable)
    self.enabledAlphaBlend = enable
end

---@public 是否开启深度写入
---@param enable boolean
function Renderer:EnableDepthWrite(enable)
    self.enabledDepthWrite = enable
end

---@public
function Renderer:Draw()
    self.canDrawing = self.vertexObject ~= nil and self.shader ~= nil
    if not  self.canDrawing then
        return
    end
    --
    if self.shader then
        --渲染前，传入一些shader需要的数据
        self.shader:SetMVPMatrix(self.projectionMatrix * self.viewMatrix)
        self.shader:SetVertexObject(self.vertexObject)
        --让Shader根据需求设置渲染状态
        self.shader:SetRenderState(self)
    end
    --
    local verticeNum = self.vertexObject.verticesNumber
    local indicesData = self.vertexObject.indicesData
    local viewSpaceVertices = {}
    local visableVertices = {}
    local visableTriangles = {}
    local vertexShaderOutputList = {}
    --
    --将所有顶点转换到观察空间
    for vertexIdx = 1,verticeNum do
        local point = self.vertexObject:GetVertexData(1,vertexIdx)
        local vertex = vec4.new(point[1],point[2],point[3],1)
        viewSpaceVertices[vertexIdx] = self.viewMatrix * vertex
    end
    --在观察空间中，剔除背面的三角形
    for triIdx = 0,self.vertexObject.trianglesNumber - 1 do
        local startIdx = triIdx * 3
        local vertexIdx1 = indicesData[startIdx + 1]
        local vertexIdx2 = indicesData[startIdx + 2]
        local vertexIdx3 = indicesData[startIdx + 3]
        local p1 = viewSpaceVertices[ vertexIdx1 ]
        local p2 = viewSpaceVertices[ vertexIdx2 ]
        local p3 = viewSpaceVertices[ vertexIdx3 ]
        local p12 = p2 - p1
        local p13 = p3 - p1
        --通过叉乘取三角形的法线。（我们使用的是右手坐标系)
        --p12 X p13
        local crossX = p12.y * p13.z - p12.z * p13.y
        local crossY = p12.z * p13.x - p12.x * p13.z
        local crossZ = p12.x * p13.y - p12.y * p13.x
        --通过点乘取三角形法线与三角形第一个点到原点的方向向量的夹角
        local dot = crossX * (0 - p1.x) + crossY * (0 - p1.y) + crossZ * (0 - p1.z)
        if dot < 0 then--夹角大于90度，表示该三角形面向视点，需要渲染出来
            visableTriangles[#visableTriangles + 1] = triIdx
            visableVertices[vertexIdx1] = 1
            visableVertices[vertexIdx2] = 1
            visableVertices[vertexIdx3] = 1
        end
    end
    --执行顶点着色器，着色器应当返回顶点的裁剪空间坐标
    for vertexIdx in pairs(visableVertices) do
        self.shader:SetCurVertexIndex(vertexIdx)
        ---@type VertexShaderOutput
        local vertexShaderOutput = self.shader:VertexShader()
        if vertexShaderOutput.clipPos then
            vertexShaderOutputList[vertexIdx] = vertexShaderOutput
        end
    end
    --光栅化三角形
    for i = 1,#visableTriangles do
        local startIdx = visableTriangles[i] * 3
        local p1 = vertexShaderOutputList[ indicesData[startIdx + 1] ]
        local p2 = vertexShaderOutputList[ indicesData[startIdx + 2] ]
        local p3 = vertexShaderOutputList[ indicesData[startIdx + 3] ]
        if p1 and p2 and p3 then
            self:TriangleRasterization(p1,p2,p3)
        end
    end
end

---@private
---@param vertex1 VertexShaderOutput
---@param vertex2 VertexShaderOutput
---@param vertex3 VertexShaderOutput
function Renderer:TriangleRasterization(vertex1,vertex2,vertex3)
    local frag1 = self:GenFragmentInput(vertex1)
    local frag2 = self:GenFragmentInput(vertex2)
    local frag3 = self:GenFragmentInput(vertex3)
    local p1 = frag1.screenPos
    local p2 = frag2.screenPos
    local p3 = frag3.screenPos
    local f23 = function(x,y) return self:CalcuBarycentricCoord(p2,p3,x,y) end
    local f31 = function(x,y) return self:CalcuBarycentricCoord(p3,p1,x,y) end
    local f12 = function(x,y) return self:CalcuBarycentricCoord(p1,p2,x,y) end
    local alpha = f23(p1.x,p1.y)
    local beta  = f31(p2.x,p2.y)
    local gamma = f12(p3.x,p3.y)
    local minX,maxX,minY,maxY = self:CalcuTriangleBound(p1,p2,p3)
    for y = minY,maxY do
        for x = minX,maxX do
            --求像素在三角形中的重心坐标
            local a = f23(x,y) / alpha
            local b = f31(x,y) / beta
            local c = f12(x,y) / gamma
            if a >= 0 and b >= 0 and c >= 0 then
                --使用重心坐标对齐次空间坐标进行插值，z分量作为片元的深度值
                local fragmentDepth = frag1.canonicalPos.z * a + frag2.canonicalPos.z * b + frag3.canonicalPos.z * c
                local depthBuffer = self.depthBuffer[x][y]
                --先进行深度测试（深度值越大表示越接近视点）
                if depthBuffer == 0 or fragmentDepth > depthBuffer then
                    --写入深度值
                    if self.enabledDepthWrite then
                        self.depthBuffer[x][y] = fragmentDepth
                    end
                    --使用重心坐标进行片元差值
                    local fragment = self:FragmentInterpolation(a,b,c,frag1,frag2,frag3)
                    --执行片元着色器
                    local dstColor = self.shader:FragmentShader(fragment)
                    --执行Alpha融合
                    local alphaFactor = self.enabledAlphaBlend and dstColor.w or 1
                    local srcColor = self.pixelBuffer[x][y]
                    local finalR = srcColor[1] * (1 - alphaFactor) + dstColor.x * alphaFactor
                    local finalG = srcColor[2] * (1 - alphaFactor) + dstColor.y * alphaFactor
                    local finalB = srcColor[3] * (1 - alphaFactor) + dstColor.z * alphaFactor
                    --把最终颜色写入像素缓存
                    self:WritePixel(x,y,finalR,finalG,finalB)
                end
                --
            end
        end
    end
end


---@private
---@param input vertexShaderOutput
---@return FragmentShaderInput
function Renderer:GenFragmentInput(input)
    ---@type FragmentShaderInput
    local fragmentShaderInput = {}
    local ve3One = vec3.one()
    --
    for k,v in pairs(input) do
        --通过做一次乘法达到克隆的目的
        fragmentShaderInput[k] = v * ve3One
    end
    --裁剪空间坐标专为齐次坐标
    local canonicalPos = input.clipPos:toVector3()
    --变换到屏幕坐标
    local screenX,screenY = mat4x4.mulXYZW(self.screenMatrix,canonicalPos.x,canonicalPos.y,0,1)
    fragmentShaderInput.canonicalPos = canonicalPos
    fragmentShaderInput.screenPos = vec2.new(luaMath.floor(screenX) + 0.5,luaMath.floor(screenY) + 0.5)
    return fragmentShaderInput
end

---@private 计算2d空间三角形轴对称包围盒
function Renderer:CalcuTriangleBound(p1,p2,p3)
    local minX = 0
    local maxX = 0
    local minY = 0
    local maxY = 0
    local Math = luaMath
    --
    minX = Math.min(minX,p1.x)
    maxX = Math.max(maxX,p1.x)
    minY = Math.min(minY,p1.y)
    maxY = Math.max(maxY,p1.y)
    --
    minX = Math.min(minX,p2.x)
    maxX = Math.max(maxX,p2.x)
    minY = Math.min(minY,p2.y)
    maxY = Math.max(maxY,p2.y)
    --
    minX = Math.min(minX,p3.x)
    maxX = Math.max(maxX,p3.x)
    minY = Math.min(minY,p3.y)
    maxY = Math.max(maxY,p3.y)
    return luaMath.floor(minX),luaMath.ceil(maxX),luaMath.floor(minY),luaMath.ceil(maxY)
end

---@private
function Renderer:CalcuBarycentricCoord(triP1,triP2,pixelX,pixelY)
    local ret = (triP1.y - triP2.y) * pixelX + (triP2.x - triP1.x) * pixelY + triP1.x * triP2.y - triP1.y * triP2.x
    return ret
end

---@private
---@return FragmentShaderInput
function Renderer:FragmentInterpolation(x,y,z,frag1,frag2,frag3)
    local ret = {}
    for k in pairs(frag1) do
        ret[k] = frag1[k] * x + frag2[k] * y + frag3[k] * z
    end
    return ret
end


---@public
function Renderer:DrawLine(x0,y0,x1,y1)
    local swap = function(a,b)
        local t = a
        a = b
        b = t
        return a,b
    end
    local steep = luaMath.abs(y1 - y0) > luaMath.abs(x1 - x0)
    if steep then
        x0,y0 = swap(x0,y0)
        x1,y1 = swap(x1,y1)
    end
    if x0 > x1 then
        x0,x1 = swap(x0,x1)
        y0,y1 = swap(y0,y1)
    end
    local deltax = x1 - x0
    local deltay = luaMath.abs(y1 - y0)
    local error = 0
    local slope = deltay / deltax
    local ystep = 0
    local y = y0
    if y0 < y1 then ystep = 1 else ystep = -1 end
    for x = x0,x1 do
        if steep then
            self:WritePixel(y,x,1,0,0)
        else
            self:WritePixel(x,y,1,0,0)
        end
        error = error + slope
        if error >= 0.5 then
            y = y + ystep
            error = error - 1
        end
    end
end

return Renderer